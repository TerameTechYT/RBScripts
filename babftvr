local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
if not getgenv().Network then
	getgenv().Network = {
		BaseParts = {};
		FakeConnections = {};
		Connections = {};
		Output = {
			Enabled = true;
			Prefix = "[NETWORK BYPASS] ";
			Send = function(Type,Output,BypassOutput)
				if typeof(Type) == "function" and (Type == print or Type == warn or Type == error) and typeof(Output) == "string" and (typeof(BypassOutput) == "nil" or typeof(BypassOutput) == "boolean") then
					if Network["Output"].Enabled == true or BypassOutput == true then
						Type(Network["Output"].Prefix..Output);
					end;
				elseif Network["Output"].Enabled == true then
					error(Network["Output"].Prefix.."Output Send Error : Invalid syntax.");
				end;
			end;
		};
		CharacterRelative = false;
	}

	Network["Output"].Send(print,": Loading.")
	Network["Velocity"] = Vector3.new(14.46262424,14.46262424,14.46262424); --exactly 25.1 magnitude
	Network["RetainPart"] = function(Part,ReturnFakePart) --function for retaining ownership of unanchored parts
		assert(typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(workspace),Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg1 (Part) must be a BasePart which is a descendant of workspace.")
		assert(typeof(ReturnFakePart) == "boolean" or typeof(ReturnFakePart) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg2 (ReturnFakePart) must be a boolean or nil.")
		if not table.find(Network["BaseParts"],Part) then
			if Network.CharacterRelative == true then
				local Character = LocalPlayer.Character
				if Character and Character.PrimaryPart then
					local Distance = (Character.PrimaryPart.Position-Part.Position).Magnitude
					if Distance > 1000 then
						Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is more than "..gethiddenproperty(LocalPlayer,"MaximumSimulationRadius").." studs away.")
						return false
					end
				else
					Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as the LocalPlayer Character's PrimaryPart does not exist.")
					return false
				end
			end
			table.insert(Network["BaseParts"],Part)
			Part.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
			Network["Output"].Send(print,"PartOwnership Output : PartOwnership applied to BasePart "..Part:GetFullName()..".")
			if ReturnFakePart == true then
				return FakePart
			end
		else
			Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it already active.")
			return false
		end
	end

	Network["RemovePart"] = function(Part) --function for removing ownership of unanchored part
		assert(typeof(Part) == "Instance" and Part:IsA("BasePart"),Network["Output"].Prefix.."RemovePart Error : Invalid syntax: Arg1 (Part) must be a BasePart.")
		local Index = table.find(Network["BaseParts"],Part)
		if Index then
			table.remove(Network["BaseParts"],Index)
			Network["Output"].Send(print,"RemovePart Output: PartOwnership removed from BasePart "..Part:GetFullName()..".")
		else
			Network["Output"].Send(warn,"RemovePart Warning : BasePart "..Part:GetFullName().." not found in BaseParts table.")
		end
	end

	Network["SuperStepper"] = Instance.new("BindableEvent") --make super fast event to connect to
	for _,Event in pairs({RunService.Stepped,RunService.Heartbeat}) do
		Event:Connect(function()
			return Network["SuperStepper"]:Fire(Network["SuperStepper"],tick())
		end)
	end

	Network["PartOwnership"] = {};
	Network["PartOwnership"]["PreMethodSettings"] = {};
	Network["PartOwnership"]["Enabled"] = false;
	Network["PartOwnership"]["Enable"] = coroutine.create(function() --creating a thread for network stuff
		if Network["PartOwnership"]["Enabled"] == false then
			Network["PartOwnership"]["Enabled"] = true --do cool network stuff before doing more cool network stuff
			Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus = LocalPlayer.ReplicationFocus
			LocalPlayer.ReplicationFocus = workspace
			Network["PartOwnership"]["PreMethodSettings"].SimulationRadius = gethiddenproperty(LocalPlayer,"SimulationRadius")
			Network["PartOwnership"]["Connection"] = Network["SuperStepper"].Event:Connect(function() --super fast asynchronous loop
				sethiddenproperty(LocalPlayer,"SimulationRadius", 0/0)
				for _,Part in pairs(Network["BaseParts"]) do --loop through parts and do network stuff
					coroutine.wrap(function()
						if Part:IsDescendantOf(workspace) then
							if Network.CharacterRelative == true then
								local Character = LocalPlayer.Character;
								if Character and Character.PrimaryPart then
									local Distance = (Character.PrimaryPart.Position - Part.Position).Magnitude
									if Distance > 1000 then
										Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is more than "..gethiddenproperty(LocalPlayer,"MaximumSimulationRadius").." studs away.")
										Lost = true;
										Network["RemovePart"](Part)
									end
								else
									Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as the LocalPlayer Character's PrimaryPart does not exist.")
								end
							end
							Part.Velocity = Network["Velocity"] + Vector3.new(0,math.cos(tick()*10)/100,0) --keep network by sending physics packets of 30 magnitude + an everchanging addition in the y level so roblox doesnt get triggered and fuck your ownership
						else
							Network["RemovePart"](Part)
						end
					end)()
				end
			end)
			Network["Output"].Send(print,"PartOwnership Output : PartOwnership enabled.")
		else
			Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already enabled.")
		end
	end)
	Network["PartOwnership"]["Disable"] = coroutine.create(function()
		if Network["PartOwnership"]["Connection"] then
			Network["PartOwnership"]["Connection"]:Disconnect()
			LocalPlayer.ReplicationFocus = Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus
			sethiddenproperty(LocalPlayer,"SimulationRadius",Network["PartOwnership"]["PreMethodSettings"].SimulationRadius)
			Network["PartOwnership"]["PreMethodSettings"] = {}
			for _,Part in pairs(Network["BaseParts"]) do
				Network["RemovePart"](Part)
			end
			Network["PartOwnership"]["Enabled"] = false
			Network["Output"].Send(print,"PartOwnership Output : PartOwnership disabled.")
		else
			Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already disabled.")
		end
	end)
	Network["Output"].Send(print,": Loaded.")
end

coroutine.resume(Network["PartOwnership"]["Enable"])

wait()

-- local StarterGui = game:GetService("StarterGui")
-- StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Health, false)

tooldb = false
player = game:GetService("Players").LocalPlayer
Camera = workspace.CurrentCamera
mouse = player:GetMouse()

VRService = game:GetService("VRService")

-- StarterGui:SetCore("VREnableControllerModels", false)

folder = Instance.new("Model", workspace)
InventoryFake = Instance.new("Folder", game.ReplicatedStorage)
InventoryFake.Name = "InventoryFake"
folder2 = Instance.new("Folder", folder)
folder.Name = "PlayerClone"
folder2.Name = "VRArms" -- haha yes
hand1 = player.Character["Left Arm"]:Clone()
hand2 = player.Character["Right Arm"]:Clone()
hand1.Anchored = true
hand2.Anchored = true
hand1.CanCollide = true
hand2.CanCollide = true
hand1.Name = "Left VR Arm"
hand2.Name = "Right VR Arm"
hand1.Parent = folder2
hand2.Parent = folder2

hand1.Transparency = 1
hand2.Transparency = 1

player.Character.Archivable = true
clone = player.Character:Clone()
clone.Name = player.Name.." Clone"
clone.Parent = folder

player.Character.Torso:Destroy()

player.Character = nil

Char = nil

Camera.CameraType = Enum.CameraType.Scriptable

Camera.HeadScale = 2

for _,Event in pairs({RunService.Stepped,RunService.Heartbeat}) do
	Event:Connect(function()
		if vbreak == true then return end
		lefthandpos = (Camera.CFrame - Camera.CFrame.p) * (VRService:GetUserCFrame(Enum.UserCFrame.LeftHand) - VRService:GetUserCFrame(Enum.UserCFrame.LeftHand).p) + Camera.CFrame*(VRService:GetUserCFrame(Enum.UserCFrame.LeftHand).p*Camera.HeadScale)
		righthandpos = (Camera.CFrame - Camera.CFrame.p) * (VRService:GetUserCFrame(Enum.UserCFrame.RightHand) - VRService:GetUserCFrame(Enum.UserCFrame.RightHand).p) + Camera.CFrame*(VRService:GetUserCFrame(Enum.UserCFrame.RightHand).p*Camera.HeadScale)
		Headpos = workspace.CurrentCamera:GetRenderCFrame()
	end)
end

for i,v in pairs(clone:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
        v.Anchored = true
		v.CanCollide = false
	end
end

con1 = nil

player.CharacterAdded:Connect(function(Character)
    wait()
    Character:SetPrimaryPartCFrame(Headpos - Headpos.UpVector * 1.5)
end)

player.CharacterAppearanceLoaded:Connect(function(Character)
	if player.Character ~= nil then
		if vbreak == true then return end
		Char = Character
		mouse.TargetFilter = Char
		Char:WaitForChild("Head").CanCollide = false
		Char:WaitForChild("Head").Transparency = 1
		Char:WaitForChild("Torso").CanCollide = false
		Char:WaitForChild("Torso").Transparency = 1
		Char["Animate"]:Destroy()
        Char["Left Arm"].Transparency = 1
        Char["Right Arm"].Transparency = 1
		Char["Left Leg"]:Destroy()
		Char["Right Leg"]:Destroy()
        -- Char["Humanoid"]:Destroy()
        -- Char["Torso"]:Destroy()
        for i,v in pairs(Char:GetDescendants()) do
			if v:IsA("BasePart") then
				Network.RetainPart(v)
				v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
				v.CanCollide = false
			end
			if v:IsA("Accessory") then
				v.Handle.Transparency = 1
			end
		end
		for _,Event in pairs({RunService.Stepped,RunService.Heartbeat}) do
			Event:Connect(function()
                Char.Torso["Left Shoulder"].C0 = Char.Torso["Left Shoulder"].C0 *(lefthandpos * CFrame.Angles(math.rad(90),0,0) - lefthandpos.LookVector * 0.65):ToObjectSpace(Headpos - Headpos.UpVector * 1.5)
				Char.Torso["Right Shoulder"].C0 = Char.Torso["Right Shoulder"].C0 * (righthandpos * CFrame.Angles(math.rad(90),0,0) - righthandpos.LookVector * 0.65):ToObjectSpace(Headpos - Headpos.UpVector * 1.5)
                hand1.CFrame = lefthandpos * CFrame.Angles(math.rad(90),0,0) - lefthandpos.LookVector * 0.65
				hand2.CFrame = righthandpos * CFrame.Angles(math.rad(90),0,0) - righthandpos.LookVector * 0.65
                -- if Char:FindFirstChildOfClass("Tool") and clone:FindFirstChildOfClass("Tool"):FindFirstChild("Handle") then
                    -- Char:FindFirstChildOfClass("Tool"):FindFirstChild("Handle").CFrame = hand2.CFrame * CFrame.Angles(math.rad(270), 0, 0) + Vector3.new(0, 0, 1)
                -- end
				Char:SetPrimaryPartCFrame(Headpos - Headpos.UpVector * 1.5)
				clone:SetPrimaryPartCFrame(Headpos - Headpos.UpVector * 1.5)
				for i,v in pairs(Char:GetDescendants()) do
					if v:IsA("Accessory") then
						v.Handle.CFrame = clone[v.Name].Handle.CFrame
					end
				end
			end)
		end
	end
    print("Loaded Character Appearance")
end)

cooldown = false

UserInputService = game:GetService("UserInputService")

UserInputService.InputChanged:Connect(function(input)
	if vbreak == true then return end
	if input.KeyCode == Enum.KeyCode.Thumbstick2 then
		Camera.CFrame += righthandpos.LookVector * (input.Position.Y/2)
		Camera.CFrame += righthandpos.RightVector * (input.Position.X/2)
	end
    if input.KeyCode == Enum.KeyCode.ButtonR2 then
        if Char:FindFirstChildOfClass("Tool") then
            Char:FindFirstChildOfClass("Tool"):Activate()
            return
        end
	end
	if input.KeyCode == Enum.KeyCode.Thumbstick1 and cooldown == false then
		local angle = 30
		if -input.Position.X < 0 then
			angle = -30
		end

		Camera.CFrame *= CFrame.Angles(0,math.rad(angle),0)
		cooldown = true
		wait(0.4)
		cooldown = false
	end
end)

Camera:GetPropertyChangedSignal("CameraType"):Connect(function()
	if vbreak == true then return end
	Camera.CameraType = Enum.CameraType.Scriptable
end)